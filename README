// vim: ft=asciidoc

Introduction
------------

aa-scan3 is a tool to help generate AppArmor profiles by inspecting the
executables to protect with AppArmor.

aa-scan3 is a build-time tool, not a run-time tool; its intended usage
is during build: it does not attempt to run the executable. Instead, it
scans it to generate the profile.

"Scanning" is a broad description. aa-scan3 is plugins-based, and all
plugins are presented the executable. Each plugin has its own "scanning"
method: inspecting the file for patterns, looking for associated files
on the side, etc...


Calling aa-scan3
----------------

aa-scan3 takes a set of global options, plus the options specified by
each plugins.

Run `aa-scan3 -h` for the set of options.


Writting a plugin
-----------------

Plugins must be implemented in Python 3.5, and must work with Python 3.5
or later. [TBC: where to install plugins?]

Plugins are named by their file name. E.g. a file named 'foo.py' will
declare a plugin named 'foo'. Plugin names must consist of only letters,
underscores and numbers.

A plugin must contain a docstring at the module-level, that provides
the help text for that plugin, help text that will be displayed in the
output of `aa-scan3 --help` in a section dedicated to that plugin.

A plugin must declare a class named `Scanner`. The constructor for that
class must accept a single parameter, `parser`, which is an object that
exposes a `add_argument` method that behaves like
https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument[ArgumentParser.add_argument].

The constructor may call `parser.add_argument()` to register options for
that plugin, if needs to. Those options will be registered in the main
`aa-scan3` argument parser, with the name of the plugin inserted at the
begining of the option. The values for those options are then set as
attributes to the single instance of that class.

For example, if the plugin `foo` calls `parser.add_argument("--hello")`,
then the option `--foo-hello` is registered, and the attribute `hello`
is added to the instance of `foo.Scanner()`.

Three extra attributes are also set:

* `profile`, which represent the current profile to generate; see below
   for the methods exposed by that object;

* `root_dir` and `staging_dir`, as set from the generic `aa-scan3`
  options.

NOTE: The attributes are set after the `__init__()` method is called, so
they are *not* available in `__init__()`.

The `profile` attribute added to the plugin instance exposes the following
methods:

* `get_path()`: returns the path of the input file

* `add_path(path, mode)`: add a rule to allow the specified `path` to be
  accessed with
  https://gitlab.com/apparmor/apparmor/-/wikis/AppArmor_Core_Policy_Reference#file-permissions[`mode`].

* `add_capability(capability)`: add a rule to allow the specified
  `capability`, from the list of
  https://gitlab.com/apparmor/apparmor/-/wikis/AppArmor_Core_Policy_Reference#capability-rules[supported
  capabilities].

* `add_network(domain, protocol)`: add a rule to allow network access
  for the the specified
  https://gitlab.com/apparmor/apparmor/-/wikis/AppArmor_Core_Policy_Reference#network-rules[domain
  and protocol].

* `start_child_profile(path)`: start a child profile for program at
  `path`; subsequent calls to `add_path()`, `add_capability()`, or
  `add_network()` will apply to this child profile. Only one level
  of child profile nestign is supported.

* `end_child_profile()`: end the current child profile; subsequent calls
  to `add_path()`, `add_capability()`, or `add_network()` will apply to
  the main profile.
